import { Exercise } from '@/lib/types';

export const systemsInteractionsExercises: Exercise[] = [
  {
    id: 'systems-ex-01',
    topicId: 'systems-interactions',
    slug: 'identificar-componentes',
    title: 'Identificar Componentes de un Sistema',
    description: 'Practica identificando los componentes frontend, backend y base de datos en diferentes aplicaciones.',
    statement: 'Para cada una de las siguientes aplicaciones, identifica qué sería el frontend, backend y base de datos:\n\n1. Una aplicación de redes sociales (como Instagram)\n2. Un sitio de compras online (como Amazon)\n3. Una aplicación de mensajería (como WhatsApp)\n4. Un sistema de banca online\n\nExplica qué hace cada componente en cada caso.',
    difficulty: 'basic',
    order: 1,
    type: 'fill-blank',
    hints: [
      'El frontend es lo que el usuario ve e interactúa',
      'El backend procesa solicitudes y lógica de negocio',
      'La base de datos almacena información',
      'Piensa en qué sucede cuando subes una foto en Instagram',
    ],
    solution: {
      answer: 'Componentes identificados correctamente',
      explanation: '**1. Red Social (Instagram):**\n\n**Frontend:**\n- App móvil (iOS/Android) donde ves fotos, subes contenido\n- Sitio web donde navegas\n- Interfaz de usuario completa\n\n**Backend:**\n- Servidores que procesan imágenes\n- Sistema de notificaciones\n- Lógica de recomendaciones\n- APIs que manejan solicitudes\n\n**Base de datos:**\n- Información de usuarios\n- Fotos y metadata\n- Comentarios y likes\n- Relaciones entre usuarios\n\n**2. E-commerce (Amazon):**\n\n**Frontend:**\n- Sitio web con catálogo de productos\n- App móvil\n- Carrito de compras visible\n\n**Backend:**\n- Sistema de búsqueda\n- Procesamiento de pagos\n- Gestión de inventario\n- Recomendaciones\n\n**Base de datos:**\n- Catálogo de productos\n- Precios e inventario\n- Órdenes y transacciones\n- Datos de clientes\n\n**3. Mensajería (WhatsApp):**\n\n**Frontend:**\n- App móvil con interfaz de chat\n- Lista de conversaciones\n\n**Backend:**\n- Servidores que enrutan mensajes\n- Sistema de notificaciones push\n- Encriptación\n\n**Base de datos:**\n- Mensajes (encriptados)\n- Contactos\n- Grupos\n\n**4. Banca Online:**\n\n**Frontend:**\n- Sitio web o app del banco\n- Interfaz para ver saldos, transferencias\n\n**Backend:**\n- Procesamiento de transacciones\n- Verificación de identidad\n- Lógica de seguridad\n\n**Base de datos:**\n- Información de cuentas\n- Historial de transacciones\n- Datos de clientes',
      steps: [
        'Piensa en qué ve el usuario (eso es frontend)',
        'Piensa en qué procesa las acciones del usuario (eso es backend)',
        'Piensa en dónde se guarda la información (eso es base de datos)',
        'Para cada aplicación, identifica estos tres componentes',
        'Explica la función de cada componente',
      ],
    },
  },
  {
    id: 'systems-ex-02',
    topicId: 'systems-interactions',
    slug: 'diferencias-frontend-backend',
    title: 'Diferencias entre Frontend y Backend',
    description: 'Comprende las diferencias fundamentales entre frontend y backend.',
    statement: 'Explica las diferencias principales entre frontend y backend. Incluye:\n\n1. Dónde se ejecuta cada uno\n2. Qué tecnologías usa cada uno\n3. Qué responsabilidades tiene cada uno\n4. Ejemplos de código de cada uno\n\nLuego, describe cómo se comunican entre sí.',
    difficulty: 'basic',
    order: 2,
    type: 'fill-blank',
    hints: [
      'El frontend se ejecuta en el navegador o dispositivo del usuario',
      'El backend se ejecuta en servidores',
      'Frontend usa HTML, CSS, JavaScript',
      'Backend puede usar muchos lenguajes',
      'Se comunican mediante HTTP',
    ],
    solution: {
      answer: 'Diferencias explicadas correctamente',
      explanation: '**Diferencias principales:**\n\n**1. Dónde se ejecuta:**\n\n**Frontend:**\n- Se ejecuta en el navegador del usuario\n- O en la app móvil del dispositivo\n- Código visible para el usuario\n\n**Backend:**\n- Se ejecuta en servidores remotos\n- No es visible para el usuario\n- Puede estar en cualquier parte del mundo\n\n**2. Tecnologías:**\n\n**Frontend:**\n```html\n<!-- HTML -->\n<button id="miBoton">Haz clic</button>\n```\n```css\n/* CSS */\nbutton {\n    background-color: blue;\n    color: white;\n}\n```\n```javascript\n// JavaScript\ndocument.getElementById("miBoton").addEventListener("click", function() {\n    alert("¡Hola!");\n});\n```\n\n**Backend:**\n```javascript\n// Node.js\nconst express = require("express");\nconst app = express();\n\napp.get("/usuarios", (req, res) => {\n    res.json({ usuarios: [...] });\n});\n```\n\n**3. Responsabilidades:**\n\n**Frontend:**\n- Mostrar información al usuario\n- Capturar interacciones del usuario\n- Validar formularios (lado cliente)\n- Hacer la interfaz atractiva\n\n**Backend:**\n- Procesar lógica de negocio\n- Acceder a bases de datos\n- Autenticar usuarios\n- Asegurar datos\n- Procesar pagos\n\n**4. Comunicación:**\n\nEl frontend y backend se comunican mediante HTTP:\n\n```javascript\n// Frontend hace solicitud\nfetch("https://api.ejemplo.com/usuarios")\n    .then(response => response.json())\n    .then(data => {\n        console.log(data);\n    });\n```\n\n```javascript\n// Backend responde\napp.get("/usuarios", (req, res) => {\n    const usuarios = obtenerUsuariosDeBD();\n    res.json(usuarios);\n});\n```',
      steps: [
        'Explica dónde se ejecuta cada uno',
        'Menciona las tecnologías principales',
        'Describe las responsabilidades',
        'Muestra ejemplos de código',
        'Explica cómo se comunican mediante HTTP',
      ],
    },
  },
  {
    id: 'systems-ex-03',
    topicId: 'systems-interactions',
    slug: 'metodos-http',
    title: 'Métodos HTTP y sus Usos',
    description: 'Practica identificando qué método HTTP usar en diferentes situaciones.',
    statement: 'Para cada una de las siguientes acciones, identifica qué método HTTP deberías usar:\n\n1. Cargar la página principal de un sitio web\n2. Enviar un formulario de registro\n3. Actualizar tu perfil de usuario\n4. Eliminar un comentario\n5. Ver la lista de productos en una tienda online\n6. Buscar usuarios en una red social\n\nExplica por qué elegiste cada método.',
    difficulty: 'basic',
    order: 3,
    type: 'fill-blank',
    hints: [
      'GET es para obtener información',
      'POST es para crear algo nuevo',
      'PUT/PATCH es para actualizar',
      'DELETE es para eliminar',
      'GET no debe cambiar datos en el servidor',
    ],
    solution: {
      answer: 'Métodos HTTP identificados correctamente',
      explanation: '**1. Cargar página principal:**\n- **Método:** GET\n- **Razón:** Solo estás obteniendo información, no modificas nada\n- **Ejemplo:** `GET /`\n\n**2. Enviar formulario de registro:**\n- **Método:** POST\n- **Razón:** Estás creando un nuevo usuario\n- **Ejemplo:** `POST /usuarios`\n```javascript\nfetch("/usuarios", {\n    method: "POST",\n    body: JSON.stringify({\n        nombre: "Juan",\n        email: "juan@email.com"\n    })\n});\n```\n\n**3. Actualizar perfil:**\n- **Método:** PUT o PATCH\n- **Razón:** Estás actualizando información existente\n- **PUT:** Actualiza todo el recurso\n- **PATCH:** Actualiza solo campos específicos\n- **Ejemplo:** `PUT /usuarios/123`\n\n**4. Eliminar comentario:**\n- **Método:** DELETE\n- **Razón:** Estás eliminando un recurso\n- **Ejemplo:** `DELETE /comentarios/456`\n\n**5. Ver lista de productos:**\n- **Método:** GET\n- **Razón:** Solo estás obteniendo información\n- **Ejemplo:** `GET /productos`\n\n**6. Buscar usuarios:**\n- **Método:** GET\n- **Razón:** Estás obteniendo resultados de búsqueda\n- **Ejemplo:** `GET /usuarios?busqueda=juan`\n\n**Resumen:**\n- GET: Solo lectura, no modifica\n- POST: Crear nuevo recurso\n- PUT/PATCH: Actualizar recurso existente\n- DELETE: Eliminar recurso',
      steps: [
        'Identifica si la acción lee o modifica datos',
        'Si solo lee, usa GET',
        'Si crea algo nuevo, usa POST',
        'Si actualiza, usa PUT o PATCH',
        'Si elimina, usa DELETE',
        'Explica tu razonamiento para cada caso',
      ],
    },
  },
  {
    id: 'systems-ex-04',
    topicId: 'systems-interactions',
    slug: 'tipos-bases-datos',
    title: 'SQL vs NoSQL: Cuándo Usar Cada Una',
    description: 'Aprende a decidir entre bases de datos SQL y NoSQL según el caso de uso.',
    statement: 'Para cada uno de estos casos, decide si usarías una base de datos SQL o NoSQL y explica por qué:\n\n1. Sistema de blog con usuarios, posts y comentarios\n2. Sistema de logging que guarda millones de eventos por día\n3. Carrito de compras de e-commerce\n4. Red social con relaciones complejas entre usuarios\n5. Sistema de caché para sesiones de usuario\n6. Aplicación de análisis de datos con estructura variable',
    difficulty: 'intermediate',
    order: 4,
    type: 'fill-blank',
    hints: [
      'SQL es bueno para datos estructurados con relaciones',
      'NoSQL es bueno para datos no estructurados o que escalan mucho',
      'Piensa en la estructura de los datos',
      'Considera la necesidad de escalabilidad',
      'Redis es excelente para caché',
    ],
    solution: {
      answer: 'Decisión de base de datos justificada para cada caso',
      explanation: '**1. Sistema de blog:**\n- **Elegir:** SQL (PostgreSQL, MySQL)\n- **Razón:** Datos estructurados con relaciones claras (usuarios → posts → comentarios). Necesitas integridad referencial y consultas complejas.\n- **Estructura:**\n```sql\nCREATE TABLE usuarios (id, nombre, email);\nCREATE TABLE posts (id, titulo, contenido, usuario_id);\nCREATE TABLE comentarios (id, texto, post_id, usuario_id);\n```\n\n**2. Sistema de logging:**\n- **Elegir:** NoSQL (MongoDB, Cassandra)\n- **Razón:** Necesitas escribir millones de registros rápidamente. Los datos pueden tener estructura variable. Escalabilidad horizontal es importante.\n\n**3. Carrito de compras:**\n- **Elegir:** SQL (PostgreSQL)\n- **Razón:** Necesitas transacciones ACID para asegurar consistencia. Datos estructurados (productos, precios, inventario).\n\n**4. Red social:**\n- **Elegir:** Puede ser ambos\n- **SQL:** Para datos estructurados (usuarios, posts)\n- **NoSQL (Grafos):** Para relaciones complejas (amistades, seguimientos)\n- **Ejemplo:** Neo4j para grafos sociales\n\n**5. Sistema de caché:**\n- **Elegir:** NoSQL (Redis)\n- **Razón:** Redis es específicamente diseñado para caché. Muy rápido, datos en memoria. Perfecto para sesiones.\n```javascript\n// Ejemplo con Redis\nredis.set("sesion:123", JSON.stringify(datosUsuario));\nconst datos = redis.get("sesion:123");\n```\n\n**6. Análisis de datos con estructura variable:**\n- **Elegir:** NoSQL (MongoDB)\n- **Razón:** Estructura variable, fácil agregar nuevos campos. Bueno para datos que cambian frecuentemente.\n\n**Resumen:**\n- **SQL:** Datos estructurados, relaciones complejas, necesidad de transacciones\n- **NoSQL:** Datos no estructurados, alta escalabilidad, estructura variable',
      steps: [
        'Analiza la estructura de los datos',
        'Considera si hay relaciones complejas',
        'Evalúa la necesidad de escalabilidad',
        'Piensa en la velocidad de lectura/escritura',
        'Decide SQL o NoSQL según el caso',
        'Justifica tu decisión',
      ],
    },
  },
  {
    id: 'systems-ex-05',
    topicId: 'systems-interactions',
    slug: 'consumir-api',
    title: 'Consumir una API desde JavaScript',
    description: 'Practica consumiendo una API REST desde código JavaScript.',
    statement: 'Escribe código JavaScript que:\n\n1. Obtenga una lista de usuarios desde la API `https://api.ejemplo.com/usuarios`\n2. Muestre los nombres de los usuarios en la consola\n3. Maneje errores apropiadamente\n4. Luego, envía un nuevo usuario usando POST a `https://api.ejemplo.com/usuarios` con los datos: nombre "María", email "maria@email.com"\n\nUsa `fetch` y tanto la sintaxis de promesas como async/await.',
    difficulty: 'intermediate',
    order: 5,
    type: 'fill-blank',
    hints: [
      'Usa fetch() para hacer solicitudes HTTP',
      'response.json() convierte la respuesta a JSON',
      'Usa try/catch con async/await',
      'Para POST, incluye method, headers y body',
      'JSON.stringify() convierte objetos a JSON',
    ],
    solution: {
      answer: 'Código para consumir API completado',
      explanation: '**Con Promesas (then/catch):**\n\n```javascript\n// 1. Obtener lista de usuarios\nfetch("https://api.ejemplo.com/usuarios")\n    .then(response => {\n        if (!response.ok) {\n            throw new Error("Error al obtener usuarios");\n        }\n        return response.json();\n    })\n    .then(data => {\n        // 2. Mostrar nombres\n        data.forEach(usuario => {\n            console.log(usuario.nombre);\n        });\n    })\n    .catch(error => {\n        // 3. Manejar errores\n        console.error("Error:", error);\n    });\n\n// 4. Crear nuevo usuario\nfetch("https://api.ejemplo.com/usuarios", {\n    method: "POST",\n    headers: {\n        "Content-Type": "application/json"\n    },\n    body: JSON.stringify({\n        nombre: "María",\n        email: "maria@email.com"\n    })\n})\n    .then(response => {\n        if (!response.ok) {\n            throw new Error("Error al crear usuario");\n        }\n        return response.json();\n    })\n    .then(data => {\n        console.log("Usuario creado:", data);\n    })\n    .catch(error => {\n        console.error("Error:", error);\n    });\n```\n\n**Con async/await (más moderno):**\n\n```javascript\n// Función para obtener usuarios\nasync function obtenerUsuarios() {\n    try {\n        const response = await fetch("https://api.ejemplo.com/usuarios");\n        \n        if (!response.ok) {\n            throw new Error("Error al obtener usuarios");\n        }\n        \n        const data = await response.json();\n        \n        // Mostrar nombres\n        data.forEach(usuario => {\n            console.log(usuario.nombre);\n        });\n        \n        return data;\n    } catch (error) {\n        console.error("Error:", error);\n    }\n}\n\n// Función para crear usuario\nasync function crearUsuario(nombre, email) {\n    try {\n        const response = await fetch("https://api.ejemplo.com/usuarios", {\n            method: "POST",\n            headers: {\n                "Content-Type": "application/json"\n            },\n            body: JSON.stringify({\n                nombre: nombre,\n                email: email\n            })\n        });\n        \n        if (!response.ok) {\n            throw new Error("Error al crear usuario");\n        }\n        \n        const nuevoUsuario = await response.json();\n        console.log("Usuario creado:", nuevoUsuario);\n        return nuevoUsuario;\n    } catch (error) {\n        console.error("Error:", error);\n    }\n}\n\n// Usar las funciones\nobtenerUsuarios();\ncrearUsuario("María", "maria@email.com");\n```',
      steps: [
        'Usa fetch() con la URL de la API',
        'Convierte la respuesta a JSON con response.json()',
        'Maneja errores con try/catch o .catch()',
        'Para POST, incluye method, headers y body',
        'Usa JSON.stringify() para el body',
        'Prueba el código en la consola del navegador',
      ],
    },
  },
  {
    id: 'systems-ex-06',
    topicId: 'systems-interactions',
    slug: 'arquitectura-sistema',
    title: 'Diseñar Arquitectura de un Sistema Simple',
    description: 'Diseña la arquitectura completa de una aplicación de tareas (To-Do App).',
    statement: 'Diseña la arquitectura completa de una aplicación de tareas (To-Do App) que permita:\n\n- Crear tareas\n- Ver lista de tareas\n- Marcar tareas como completadas\n- Eliminar tareas\n- Filtrar por estado (todas, completadas, pendientes)\n\nIncluye:\n1. Componentes del frontend (qué tecnologías usarías)\n2. Componentes del backend (qué tecnologías usarías)\n3. Estructura de la base de datos\n4. Endpoints de la API\n5. Flujo de datos cuando un usuario crea una tarea\n\nExplica cada decisión.',
    difficulty: 'intermediate',
    order: 6,
    type: 'fill-blank',
    hints: [
      'Frontend: HTML, CSS, JavaScript o framework',
      'Backend: Node.js, Python, etc.',
      'Base de datos: SQL o NoSQL',
      'API REST con endpoints para cada acción',
      'Piensa en el flujo completo de datos',
    ],
    solution: {
      answer: 'Arquitectura diseñada correctamente',
      explanation: '**1. Frontend:**\n\n**Tecnologías:**\n- HTML para estructura\n- CSS para estilos\n- JavaScript (o React/Vue) para interactividad\n\n**Componentes:**\n- Formulario para agregar tareas\n- Lista de tareas\n- Botones para marcar completadas/eliminar\n- Filtros (todas/completadas/pendientes)\n\n**2. Backend:**\n\n**Tecnologías:**\n- Node.js con Express (o Python con Flask)\n- Base de datos SQLite (desarrollo) o PostgreSQL (producción)\n\n**3. Base de Datos:**\n\n**Estructura SQL:**\n```sql\nCREATE TABLE tareas (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    texto VARCHAR(255) NOT NULL,\n    completada BOOLEAN DEFAULT FALSE,\n    fecha_creacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n```\n\n**4. Endpoints de API:**\n\n```javascript\n// Obtener todas las tareas\nGET /api/tareas\n\n// Obtener tarea específica\nGET /api/tareas/:id\n\n// Crear nueva tarea\nPOST /api/tareas\nBody: { texto: "Nueva tarea" }\n\n// Actualizar tarea (marcar como completada)\nPUT /api/tareas/:id\nBody: { completada: true }\n\n// Eliminar tarea\nDELETE /api/tareas/:id\n\n// Filtrar tareas\nGET /api/tareas?estado=completadas\nGET /api/tareas?estado=pendientes\n```\n\n**5. Flujo cuando usuario crea tarea:**\n\n```javascript\n// 1. Usuario escribe tarea y hace clic en "Agregar"\n// Frontend\nconst nuevaTarea = {\n    texto: "Comprar leche"\n};\n\nfetch("/api/tareas", {\n    method: "POST",\n    headers: { "Content-Type": "application/json" },\n    body: JSON.stringify(nuevaTarea)\n})\n    .then(response => response.json())\n    .then(tarea => {\n        // Agregar tarea a la lista en pantalla\n        mostrarTareaEnPantalla(tarea);\n    });\n\n// 2. Backend recibe solicitud\napp.post("/api/tareas", (req, res) => {\n    const { texto } = req.body;\n    \n    // 3. Backend guarda en base de datos\n    const tarea = db.query(\n        "INSERT INTO tareas (texto) VALUES (?)",\n        [texto]\n    );\n    \n    // 4. Backend responde con la tarea creada\n    res.json({\n        id: tarea.id,\n        texto: texto,\n        completada: false\n    });\n});\n\n// 5. Frontend actualiza la interfaz\n```\n\n**Flujo completo:**\n1. Usuario → Frontend (interacción)\n2. Frontend → Backend (HTTP POST)\n3. Backend → Base de datos (INSERT)\n4. Base de datos → Backend (confirmación)\n5. Backend → Frontend (respuesta JSON)\n6. Frontend → Usuario (muestra nueva tarea)',
      steps: [
        'Define tecnologías para frontend',
        'Define tecnologías para backend',
        'Diseña estructura de base de datos',
        'Lista todos los endpoints necesarios',
        'Describe el flujo paso a paso',
        'Explica cada decisión técnica',
      ],
    },
  },
  {
    id: 'systems-ex-07',
    topicId: 'systems-interactions',
    slug: 'codigos-estado-http',
    title: 'Códigos de Estado HTTP',
    description: 'Aprende a identificar y usar correctamente los códigos de estado HTTP.',
    statement: 'Para cada una de estas situaciones, identifica qué código de estado HTTP debería devolver el servidor:\n\n1. Usuario solicita una página que no existe\n2. Usuario intenta acceder sin estar autenticado\n3. Usuario crea un recurso exitosamente\n4. Usuario envía datos inválidos en un formulario\n5. El servidor tiene un error interno\n6. Usuario solicita datos y todo está bien\n7. Usuario intenta acceder a un recurso sin permisos\n8. Recurso movido permanentemente a otra URL\n\nExplica qué significa cada código y cuándo usarlo.',
    difficulty: 'intermediate',
    order: 7,
    type: 'fill-blank',
    hints: [
      '2xx = éxito',
      '3xx = redirección',
      '4xx = error del cliente',
      '5xx = error del servidor',
      '404 = no encontrado',
      '401 = no autenticado',
      '403 = sin permisos',
    ],
    solution: {
      answer: 'Códigos de estado identificados correctamente',
      explanation: '**1. Página que no existe:**\n- **Código:** 404 Not Found\n- **Significado:** El recurso solicitado no se encontró en el servidor\n- **Uso:** Cuando la URL no existe o el recurso fue eliminado\n\n**2. Sin autenticación:**\n- **Código:** 401 Unauthorized\n- **Significado:** Se requiere autenticación para acceder\n- **Uso:** Cuando el usuario no está logueado\n\n**3. Recurso creado exitosamente:**\n- **Código:** 201 Created\n- **Significado:** Recurso creado exitosamente\n- **Uso:** Después de POST exitoso que crea algo nuevo\n- **Alternativa:** 200 OK también es válido\n\n**4. Datos inválidos:**\n- **Código:** 400 Bad Request\n- **Significado:** La solicitud está mal formada o tiene datos inválidos\n- **Uso:** Cuando el usuario envía datos incorrectos\n\n**5. Error interno del servidor:**\n- **Código:** 500 Internal Server Error\n- **Significado:** Error en el servidor, no culpa del cliente\n- **Uso:** Cuando hay un bug o error en el código del servidor\n\n**6. Solicitud exitosa:**\n- **Código:** 200 OK\n- **Significado:** Solicitud procesada exitosamente\n- **Uso:** Para GET exitoso o operaciones que funcionaron\n\n**7. Sin permisos:**\n- **Código:** 403 Forbidden\n- **Significado:** El servidor entiende la solicitud pero se niega a autorizarla\n- **Uso:** Cuando el usuario está autenticado pero no tiene permisos\n- **Diferencia con 401:** 401 = no autenticado, 403 = autenticado pero sin permisos\n\n**8. Recurso movido:**\n- **Código:** 301 Moved Permanently\n- **Significado:** El recurso se movió permanentemente a otra URL\n- **Uso:** Cuando una URL cambia permanentemente\n- **Alternativa:** 302 Found para redirección temporal\n\n**Resumen por categoría:**\n- **2xx (Éxito):** 200 OK, 201 Created, 204 No Content\n- **3xx (Redirección):** 301 Moved Permanently, 302 Found\n- **4xx (Error del cliente):** 400 Bad Request, 401 Unauthorized, 403 Forbidden, 404 Not Found\n- **5xx (Error del servidor):** 500 Internal Server Error, 503 Service Unavailable',
      steps: [
        'Identifica si es éxito, redirección o error',
        'Si es error, determina si es del cliente (4xx) o servidor (5xx)',
        'Para 4xx, identifica el tipo específico',
        'Explica qué significa cada código',
        'Describe cuándo usar cada uno',
      ],
    },
  },
  {
    id: 'systems-ex-08',
    topicId: 'systems-interactions',
    slug: 'lenguajes-usos',
    title: 'Elegir Lenguaje de Programación',
    description: 'Practica eligiendo el lenguaje de programación adecuado para diferentes proyectos.',
    statement: 'Para cada uno de estos proyectos, elige qué lenguaje de programación usarías y explica por qué:\n\n1. Aplicación web full-stack (frontend y backend)\n2. Análisis de datos y machine learning\n3. Aplicación Android nativa\n4. Sistema operativo o software de bajo nivel\n5. Scripts de automatización\n6. Juego de alto rendimiento\n7. API REST simple\n8. Aplicación iOS nativa',
    difficulty: 'intermediate',
    order: 8,
    type: 'fill-blank',
    hints: [
      'JavaScript es versátil para web',
      'Python es excelente para datos y ML',
      'Kotlin/Java para Android',
      'C/C++ para bajo nivel',
      'Swift para iOS',
    ],
    solution: {
      answer: 'Lenguajes seleccionados correctamente para cada proyecto',
      explanation: '**1. Aplicación web full-stack:**\n- **Elegir:** JavaScript (Node.js para backend)\n- **Razón:** Puedes usar el mismo lenguaje en frontend y backend. Gran ecosistema (React, Express, etc.). Muy popular y con muchos recursos.\n- **Alternativa:** Python (Django) o Ruby (Rails)\n\n**2. Análisis de datos y machine learning:**\n- **Elegir:** Python\n- **Razón:** Bibliotecas excelentes (Pandas, NumPy, TensorFlow, PyTorch). Sintaxis simple. Muy usado en ciencia de datos.\n- **Ejemplo:**\n```python\nimport pandas as pd\nimport numpy as np\nfrom sklearn.model_selection import train_test_split\n```\n\n**3. Aplicación Android nativa:**\n- **Elegir:** Kotlin (recomendado) o Java\n- **Razón:** Lenguajes oficiales de Android. Kotlin es más moderno y conciso.\n- **Alternativa:** Puedes usar React Native o Flutter para multiplataforma\n\n**4. Sistema operativo o software de bajo nivel:**\n- **Elegir:** C o C++\n- **Razón:** Control total sobre hardware. Muy eficiente. Usado en sistemas operativos, drivers, software embebido.\n- **Ejemplo:** Linux kernel está escrito en C\n\n**5. Scripts de automatización:**\n- **Elegir:** Python o Bash\n- **Razón:** Python es fácil de escribir y leer. Gran para automatizar tareas. Bash es bueno para scripts de sistema.\n- **Ejemplo:**\n```python\nimport os\nimport shutil\n\n# Automatizar copia de archivos\nfor archivo in os.listdir("."):\n    if archivo.endswith(".txt"):\n        shutil.copy(archivo, "backup/")\n```\n\n**6. Juego de alto rendimiento:**\n- **Elegir:** C++ o C# (con Unity)\n- **Razón:** Necesitas máximo rendimiento. C++ es muy rápido. C# con Unity es popular para desarrollo de juegos.\n- **Alternativa:** Rust (moderno y seguro)\n\n**7. API REST simple:**\n- **Elegir:** JavaScript (Node.js/Express) o Python (Flask/FastAPI)\n- **Razón:** Desarrollo rápido. Sintaxis simple. Muchos frameworks disponibles.\n- **Ejemplo con Express:**\n```javascript\nconst express = require("express");\nconst app = express();\n\napp.get("/api/usuarios", (req, res) => {\n    res.json({ usuarios: [...] });\n});\n```\n\n**8. Aplicación iOS nativa:**\n- **Elegir:** Swift\n- **Razón:** Lenguaje oficial de Apple. Moderno, seguro y rápido. Reemplazó a Objective-C.\n- **Alternativa:** Objective-C (más antiguo)',
      steps: [
        'Considera los requisitos del proyecto',
        'Piensa en el ecosistema y bibliotecas disponibles',
        'Evalúa la facilidad de desarrollo',
        'Considera el rendimiento necesario',
        'Elige el lenguaje más apropiado',
        'Explica tu razonamiento',
      ],
    },
  },
  {
    id: 'systems-ex-09',
    topicId: 'systems-interactions',
    slug: 'seguridad-basica',
    title: 'Mejores Prácticas de Seguridad',
    description: 'Identifica problemas de seguridad en código y propón soluciones.',
    statement: 'Identifica los problemas de seguridad en este código y explica cómo corregirlos:\n\n```javascript\n// Código con problemas de seguridad\napp.post("/login", (req, res) => {\n    const usuario = req.body.usuario;\n    const password = req.body.password;\n    \n    const query = `SELECT * FROM usuarios WHERE usuario = "${usuario}" AND password = "${password}"`;\n    const resultado = db.query(query);\n    \n    if (resultado) {\n        res.json({ token: "secret-token-123" });\n    } else {\n        res.json({ error: "Credenciales inválidas" });\n    }\n});\n```\n\nLista todos los problemas que encuentres y proporciona código corregido.',
    difficulty: 'advanced',
    order: 9,
    type: 'fill-blank',
    hints: [
      'Problema de inyección SQL',
      'Contraseñas en texto plano',
      'Token hardcodeado',
      'Falta validación de entrada',
      'Falta HTTPS',
      'Mensajes de error revelan información',
    ],
    solution: {
      answer: 'Problemas de seguridad identificados y corregidos',
      explanation: '**Problemas identificados:**\n\n1. **Inyección SQL:** Usa concatenación de strings en la query\n2. **Contraseñas en texto plano:** Compara contraseñas directamente\n3. **Token hardcodeado:** Token fijo y predecible\n4. **Falta validación:** No valida entrada del usuario\n5. **Mensaje de error revelador:** Expone si usuario existe\n6. **Falta HTTPS:** Sin encriptación en tránsito\n7. **Sin rate limiting:** Vulnerable a fuerza bruta\n\n**Código corregido:**\n\n```javascript\nconst bcrypt = require("bcrypt");\nconst jwt = require("jsonwebtoken");\n\napp.post("/login", async (req, res) => {\n    try {\n        // 1. Validar entrada\n        const { usuario, password } = req.body;\n        \n        if (!usuario || !password) {\n            return res.status(400).json({ \n                error: "Usuario y contraseña requeridos" \n            });\n        }\n        \n        // 2. Usar parámetros preparados (previene SQL injection)\n        const query = "SELECT * FROM usuarios WHERE usuario = ?";\n        const resultado = await db.query(query, [usuario]);\n        \n        if (!resultado || resultado.length === 0) {\n            // 3. Mensaje genérico (no revela si usuario existe)\n            return res.status(401).json({ \n                error: "Credenciales inválidas" \n            });\n        }\n        \n        const usuarioDB = resultado[0];\n        \n        // 4. Comparar hash de contraseña (no texto plano)\n        const passwordValida = await bcrypt.compare(\n            password, \n            usuarioDB.password_hash\n        );\n        \n        if (!passwordValida) {\n            return res.status(401).json({ \n                error: "Credenciales inválidas" \n            });\n        }\n        \n        // 5. Generar token JWT seguro (no hardcodeado)\n        const token = jwt.sign(\n            { usuarioId: usuarioDB.id },\n            process.env.JWT_SECRET, // Variable de entorno\n            { expiresIn: "24h" }\n        );\n        \n        res.json({ \n            token: token,\n            usuario: {\n                id: usuarioDB.id,\n                usuario: usuarioDB.usuario\n            }\n        });\n        \n    } catch (error) {\n        console.error("Error en login:", error);\n        res.status(500).json({ \n            error: "Error interno del servidor" \n        });\n    }\n});\n\n// 6. Middleware para validar token\nfunction autenticarToken(req, res, next) {\n    const token = req.headers["authorization"]?.split(" ")[1];\n    \n    if (!token) {\n        return res.status(401).json({ error: "Token requerido" });\n    }\n    \n    jwt.verify(token, process.env.JWT_SECRET, (err, usuario) => {\n        if (err) {\n            return res.status(403).json({ error: "Token inválido" });\n        }\n        req.usuario = usuario;\n        next();\n    });\n}\n\n// 7. Usar HTTPS en producción\n// Configurar SSL/TLS\n\n// 8. Rate limiting (usando express-rate-limit)\nconst rateLimit = require("express-rate-limit");\n\nconst loginLimiter = rateLimit({\n    windowMs: 15 * 60 * 1000, // 15 minutos\n    max: 5 // máximo 5 intentos\n});\n\napp.post("/login", loginLimiter, async (req, res) => {\n    // ... código de login\n});\n```\n\n**Resumen de correcciones:**\n- ✅ Parámetros preparados para prevenir SQL injection\n- ✅ Hash de contraseñas con bcrypt\n- ✅ Tokens JWT seguros\n- ✅ Validación de entrada\n- ✅ Mensajes de error genéricos\n- ✅ Rate limiting\n- ✅ Manejo de errores apropiado',
      steps: [
        'Identifica vulnerabilidades de seguridad',
        'Corrige inyección SQL con parámetros preparados',
        'Implementa hash de contraseñas',
        'Usa tokens JWT en lugar de tokens fijos',
        'Agrega validación de entrada',
        'Mejora mensajes de error',
        'Agrega rate limiting',
      ],
    },
  },
  {
    id: 'systems-ex-10',
    topicId: 'systems-interactions',
    slug: 'arquitectura-escalable',
    title: 'Diseñar Arquitectura Escalable',
    description: 'Diseña una arquitectura escalable para una aplicación que debe manejar millones de usuarios.',
    statement: 'Diseña la arquitectura completa de una red social que debe escalar para millones de usuarios. Incluye:\n\n1. Arquitectura de frontend (considera CDN, caching)\n2. Arquitectura de backend (load balancing, microservicios)\n3. Estrategia de base de datos (sharding, replicación)\n4. Caché y almacenamiento\n5. Monitoreo y logging\n6. Seguridad y autenticación\n\nExplica cada componente y por qué es necesario para escalar.',
    difficulty: 'advanced',
    order: 10,
    type: 'fill-blank',
    hints: [
      'CDN para servir contenido estático',
      'Load balancers para distribuir tráfico',
      'Microservicios para escalar componentes independientemente',
      'Sharding para dividir bases de datos',
      'Redis para caché',
      'Monitoreo para detectar problemas',
    ],
    solution: {
      answer: 'Arquitectura escalable diseñada correctamente',
      explanation: '**1. Arquitectura de Frontend:**\n\n**CDN (Content Delivery Network):**\n- Servir imágenes, videos, CSS, JS desde servidores cercanos al usuario\n- Reduce latencia y carga en servidores principales\n- Ejemplo: CloudFront (AWS), Cloudflare\n\n**Caché del navegador:**\n- Cachear recursos estáticos\n- Reducir solicitudes al servidor\n\n**Aplicación:**\n- React/Vue para frontend\n- Server-Side Rendering (SSR) o Static Site Generation (SSG)\n- Code splitting para cargar solo código necesario\n\n**2. Arquitectura de Backend:**\n\n**Load Balancer:**\n```\nUsuarios → Load Balancer → [Servidor 1, Servidor 2, Servidor 3, ...]\n```\n- Distribuye tráfico entre múltiples servidores\n- Health checks para detectar servidores caídos\n- Ejemplo: AWS ELB, NGINX\n\n**Microservicios:**\n- **Servicio de usuarios:** Gestión de perfiles\n- **Servicio de posts:** Crear y obtener posts\n- **Servicio de mensajes:** Chat en tiempo real\n- **Servicio de notificaciones:** Push notifications\n- Cada servicio escala independientemente\n\n**API Gateway:**\n- Punto de entrada único\n- Enrutamiento a microservicios\n- Autenticación centralizada\n- Rate limiting\n\n**3. Estrategia de Base de Datos:**\n\n**Sharding (Particionamiento):**\n```\nBase de datos dividida por región o ID de usuario:\n- Shard 1: Usuarios 1-1M\n- Shard 2: Usuarios 1M-2M\n- Shard 3: Usuarios 2M-3M\n```\n- Divide datos en múltiples bases de datos\n- Escala horizontalmente\n\n**Replicación:**\n```\nMaster (escritura) → [Replica 1, Replica 2, Replica 3] (lectura)\n```\n- Una base de datos maestra para escrituras\n- Múltiples réplicas para lecturas\n- Mejora rendimiento de lectura\n\n**Bases de datos especializadas:**\n- **PostgreSQL:** Datos estructurados (usuarios, posts)\n- **MongoDB:** Contenido flexible\n- **Redis:** Caché y sesiones\n- **Elasticsearch:** Búsqueda\n\n**4. Caché y Almacenamiento:**\n\n**Redis para caché:**\n```javascript\n// Caché de posts populares\nconst postsPopulares = await redis.get("posts:populares");\nif (!postsPopulares) {\n    postsPopulares = await db.getPostsPopulares();\n    await redis.setex("posts:populares", 3600, JSON.stringify(postsPopulares));\n}\n```\n- Caché de consultas frecuentes\n- Sesiones de usuario\n- Rate limiting\n\n**Almacenamiento de archivos:**\n- **S3 (AWS)** o equivalente para imágenes/videos\n- CDN delante para servir rápido\n- Compresión de imágenes\n\n**5. Monitoreo y Logging:**\n\n**Monitoreo:**\n- **APM (Application Performance Monitoring):** New Relic, Datadog\n- Métricas de CPU, memoria, latencia\n- Alertas automáticas\n\n**Logging:**\n- **ELK Stack:** Elasticsearch, Logstash, Kibana\n- Centralizar logs de todos los servicios\n- Búsqueda y análisis\n\n**Métricas clave:**\n- Latencia de respuesta\n- Tasa de errores\n- Throughput (requests/segundo)\n- Uso de recursos\n\n**6. Seguridad y Autenticación:**\n\n**Autenticación:**\n- JWT tokens\n- OAuth 2.0 para login social\n- Refresh tokens\n\n**Seguridad:**\n- HTTPS en todas las conexiones\n- Rate limiting por IP\n- WAF (Web Application Firewall)\n- DDoS protection\n- Encriptación de datos sensibles\n\n**Arquitectura completa:**\n```\n                    [CDN]\n                     ↓\n            [Load Balancer]\n                     ↓\n        ┌────────────┴────────────┐\n        ↓                         ↓\n[API Gateway]              [Static Files]\n        ↓\n    ┌────┴────┐\n    ↓         ↓\n[Auth]   [Microservices]\n    ↓         ↓\n[Redis]  [Databases]\n          (Sharded)\n```\n\n**Resumen:**\n- CDN y caché reducen carga\n- Load balancing distribuye tráfico\n- Microservicios permiten escalar componentes\n- Sharding y replicación escalan bases de datos\n- Monitoreo detecta problemas temprano\n- Seguridad protege contra ataques',
      steps: [
        'Diseña frontend con CDN y caché',
        'Planifica backend con load balancing',
        'Considera microservicios',
        'Diseña estrategia de base de datos (sharding/replicación)',
        'Incluye sistemas de caché',
        'Planifica monitoreo y logging',
        'Considera seguridad y autenticación',
        'Explica cómo cada componente ayuda a escalar',
      ],
    },
  },
];
